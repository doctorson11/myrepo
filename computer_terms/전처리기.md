# 전처리기 (preprocessor)
전처리기란 소스파일을 컴파일 하기 전에 컴파일러에게 특별한 작업을 부여하기 위한 지시어이다. 
컴파일러는 사용자가 작성한 코드를 컴파일을 하기 전에 전처리문에서 정의해 놓은 작업들을 먼저 수행을 한 후 소스 파일을 컴파일 한다.
예: 소스를 컴파일할때 주의사항이 있는지, 
특정 파일을 참조해야 하는지, 
특정 부분은 어떻게 컴파일을 하는것이 좋은지 등
- 따라서 전처리기는 소스를 컴파일하기 전에 컴파일러가 인식해야하기 때문에 
  컴파일 전에 처리되어야해서 이름이 전처리기다.

## 작동 방식
전처리기 지시어 -> 컴파일러가 전처리기 내용 인식 -> 지시된 사항을 참고하여 컴파일 수행

전처리기는 #키워드로 시작되기 때문에 소스에서 #으로 시작되는 문장들은 모두 전처리기로
간주된다. 그리고 전처리기는 명령어가 아닌 지시어 이기 때문에 끝에 세미콜론( ; )을 사용하지
않고 컴파일시에 그 내용이 실행파일에 포함되지도 않는다.

## 종류
**[파일 포함하기]**
- **#include**
특정 프로그램 파일(이진파일이 아니라 소스 파일 같은 일반 문서 파일)을 현재 위치에 첨부하여, 하나의 파일처럼 컴파일할 때 사용한다. 
여러 개의 파일을 프로젝트에 등록을 하면, 서로 설정된 함수나 변수를 사용할 수 있다.
프로그램 파일은 보통 개별적으로 저장되고, 개별적으로 저장된 파일들은 당연히 개별적으로 컴파일된다. 이렇게 개별적으로 컴파일된 오브젝트 파일들은 어떻게 하나의 프로그램으로 실행하기 위해 #include를 사용한다. 
**즉, 서로 다른 함수나 기타 정보를 활용하기 위해서 함수형이나 변수형 또는 선언 내용을 다른 파일끼리 연결하는 것이다.**
	- <>의 형태로는 환경변수에 지정된 경로, 즉 컴파일 옵션을 지정할때 정의해 놓은 위치에서 파일을 찾게 된다.  
	- ...의 형태는 현재 코드가 위치한 곳(현재의 디렉토리/폴더)을 기본으로 파일을 찾고, 같은 폴더 안에 파일이 없으면 컴파일 옵션에서 지정한 위치에서 파일을 찾게 된다.

	예: #include <stdio.h>, #include "main.h"

**[조건부 컴파일하기]**
- **#if ~ [#elseif] ~ [#else] ~ #endif**
	- **#if**
바로 뒤에 상수 또는 이미 정의된 문자상수가 온다. 값이 0이면 다음 줄부터의 내용은 건너 뛰고, 값이 0이 아니면 처리되는 방식으로 진행된다.
	- **#ifdef**
#if와 비슷하다. 하지만, 바로 뒤에 나오는 식별자가 #define으로 미리 정의가 되어있으면 처리되고, 그렇지 않으면 건너뛴다.
	-	**#ifndef**
if not defined. 즉, 논리 부정이 추가된 #if다. 헤더파일이 겹치는 것을 방지하기 위해
`#ifndef STDIO_H__`
`#define STDIO_H__`
식으로 쓰이기도 한다.
	-	**#else, #elif**
전처리기의 조건부 컴파일은 if문의 else와 비슷하다. 즉, #else를 가지고 있고, else if와 유사하게 #elif도 있다. 방식도 이와 유사하다고 생각하면 된다.
	-	**#endif**
조건부 컴파일의 종료를 나타낸다. 즉, 마지막엔 이 기호를 적어야 한다.

**[매크로 정의와 확장]**
- **#define**
특성 숫자, 함수, 프로그램 블록을 다른 형태로 변환 지정한다. 
#define A B의 형태로 사용되며, A를 B로 치환할 것을 지시한다.  
조건은 선언된 그 줄만 해당되고, 다음 줄로 연결하고자 할 때는 C나 C++에서 했던 것처럼 '\'를 이용하면 된다.
예: #define MAX 100, #define SQUARE(x) ((x) * (x)) 
-	**#undef**
#define으로 정의한 내용을 #undef를 사용하시면 정의된 것이 없었던 일로 된다.

**[토큰 연결 연산자]**
토큰 연결 연산자는 두 개의 토큰을 하나의 토큰으로 연결하는 것을 말한다. 
>예:
#define HELLO_PROGRAMMING(name) typedef struct name##_z name##_x
HELLO_PROGRAMMING(obejct);
출력 결과:
object_z/ object_y

**[#pragma]**
컴파일레어게 특성 옵션이나 라이브러리 형태 등을 지정하고자 할 때 사용한다. 
보통, 여러 가지 환경에 프로그래밍을 적용시키고자 할 때, 또는 CPU 및 시스템 특성에 맞도록 추가하거나 삭제할 때 사용한다.
예: 회사의 컴파일러별로 C/C++표준에 속하지 않는 독자적인 지원을 하는 경우, #pragma로 컴파일러에 지시를 내리게 된다.

**[#error]**  
#error는 컴파일러에게 의도적인 에러를 발생시키도록 한다.
주로 #ifdef ~ #endif와 함께 사용되며, 특정한 함수나 기능을 지원하지 않는 경우  컴파일을 하지 못하도록 하며, 그 이유를 설명할때 사용하게 된다.
>예:	
#ifdef __WIN32
void  Init()  {  OS  =  _WIN32;}
#elif __LINUX
void  Init()  {  OS  =  _LINUX;}
#else
#error UnknownPlatform
#endif
이 코드는 WIN32나 LINUX가 아니면 UnknownPlatform이라는 컴파일 에러를 발생시킨다. 

**[#line]**  
#line은 기본정의인 __FILE__과 __LINE__을 재정의하도록 한다.  
#line A B의 형태로 사용하며, A는 __LINE__의 값을, B는 __FILE__의 값을 변경한다.  
예; #line 2 “MainFunc”
(본래 __FILE__은 소스코드의 이름을, __LINE__은 소스코드에서의 현재 라인수를 표기하는 매크로이다. )
